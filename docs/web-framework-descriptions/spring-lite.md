---
sidebar_position: 1
---

# Spring Boot 簡易版の構成解説

Spring Boot 簡易版の構成解説を行います。

## 基本構成

クリーンアーキテクチャの一種であるオニオンアーキテクチャを採用しています。
オニオンアーキテクチャは、ドメイン駆動設計（Domain-Driven Design, DDD）に基づいたソフトウェアアーキテクチャの一種です。

DDDを採用することで

- アプリケーションのロジックがコードから読み取りやすくなる
- 変更に強いコードになる

のような恩恵を受けることができます。

ドメイン駆動設計についての説明については、以下wikipediaからの引用を参照

> ドメイン駆動設計（英語: domain-driven design、DDD）とは、ドメインの専門家からの入力に従ってドメインに一致するようにソフトウェアをモデル化することに焦点を当てるソフトウェア設計手法である[1][2]。オブジェクト指向プログラミングに関しては、ソースコード（クラス名・クラスメソッド・クラス変数）の構造と名称がビジネスドメインと一致させる必要があることを意味する。

一般的に、Javaのようなオブジェクト指向な言語では、クリーンアーキテクチャを採用して開発するケースが多い。

「簡易版」としているのは完全なDDDの実装にはしておらず、一部でDDDの恩恵を受けられない実装になっています。
最初からDDDを完全に理解するのは難しく、それに対する実装の理解も時間がかかるため、重要な部分だけを抽出した「簡易版」の実装となっています。

### 参考

- https://qiita.com/k_yamaki/items/bf99d3bf64a84258a3a1
- https://zenn.dev/streamwest1629/articles/no-clean_hello-onion-architecture

## 実際のパッケージ解説

Spring Boot 簡易版のパッケージについて解説します。

そもそもJavaにおけるパッケージは、クラスやインターフェースを整理してグループ化するための仕組みです。プログラムを論理的に整理し、クラスの名前の衝突を避けるために使用されます。パッケージを使うことで、同じ名前のクラスでも異なるパッケージに配置すれば共存させることができ、またプロジェクト内のクラスを階層的に管理できるという利点があります（ChatGPTより）

以下が実際のパッケージ構成です。

```
.
├── applicaiton
│   └── usecase
├── domain
│   ├── model
│   └── repository
├── infrastructure
│   ├── db
│   │   ├── mapper
│   │   └── schema
│   └── repository
└── presentation
    ├── controller
    └── dto
        ├── request
        └── response
```

### application

アプリケーション層のクラスを配置します。既存で `usecase` パッケージを配置しており、アプリケーションのメインロジックを配置します。 `usecase` の他に、ユースケースを跨いた共通のロジックを配置する `service` パッケージを作る場合があります。

### domain

ドメイン層のクラスを配置します。アプリケーションで扱うドメインモデルの管理（`model`パッケージ）やドメインモデルの永続化を担うリポジトリの管理（`repository` パッケージ）を行います。

### presentation

プレゼンテーション層のクラスを配置します。プレゼンテーション層はオニオンアーキテクチャの一番外側に存在しており、ユーザーからのリクエストを受け付けることを担います。ルーティングを管理する `controller` パッケージや リクエストやレスポンスの情報を管理する `dto` パッケージを持ちます。

### infrastructure

インフラストラクチャ層のクラスを配置します。インフラストラクチャ層では主にデータの永続化処理や外部リソースからのデータ取得を担います。具体的にはデータベースにデータを保存したり、他のAPIにリクエストしてデータを取得したりする処理を管理します。

## 主要パッケージの依存関係

あるクラスAがあるクラスBをフィールドに持つ際に、クラスAはクラスBに依存するといい、 `クラスA -> クラスB` と書きます。

また、あるクラスCがあるインターフェースDの実装クラスである場合、クラスCはインターフェースDに依存するということもあります。

```java
class B {}

// クラスAはクラスBをフィールドに持つので、クラスAはクラスBに依存しています。
class A {
  B b;
}

interface D {
  void someMethod();
}

// クラスCはインターフェースDの実装クラスなので、クラスCはインターフェースDに依存します。
class C implements D {
  @Override
  void someMethod() {}
}
```


本アプリケーションの依存関係は以下のようになります。

```
controller -> usecase -> repository(domain層) <- repository(infrastructure層) 
```

controller、usecase、repository(domain層)までの依存関係はクラスがフィールドを持つことによる依存関係であり、repository(domain層)、repository(infrastructure層)はインターフェースとその実装クラスという依存関係を持ちます。
repository(domain層)パッケージはインターフェースだけ定義するというところがポイントです。これはdomain層がドメインモデルの永続化の機能・インターフェースを管理し、infrastructureにその実態を委譲している形をとっております。これを「依存性逆転の原則」といったりします。依存性逆転の原則は SOLID原則の一つで、ざっくり言えばプログラムの重要な部分が、重要でない部分に依存しないよう設計すべきであるという思想に基づいて実装したもので、クリーンアーキテクチャによる実装でよく出てくる形になります。

### 参考

- https://zenn.dev/naas/articles/c743a3d046fa78
- https://qiita.com/k2491p/items/686ee5dd72b4baf9a81a
- https://zenn.dev/higuruchi/articles/58a766398b9336

## DI（Dependency Injection: 依存性の注入）について

先ほど、主要パッケージの依存関係について説明しました。
依存関係が強いといくつかのデメリットがあります。

- 変更に弱い。依存先の変更があった際に、それに伴い依存元のコードも変更しないといけない場合があります。
- 単体テストコードが書きづらい。依存先のロジックによって依存元のロジック結果が異なる場合、テストとしては依存先のロジックまで考慮する必要があり、テスト開発のコストがかかります。

これらのデメリットを軽減・解消する方法がいくつかあります。一つは先ほど紹介した「依存性逆転の原則」です。インターフェースとその実装を分割して定義することで、変更に強いコーディングが可能となります。他の方法の一つにDIがあります。

DIはDependency Injection、日本語で依存性の注入といい、クラス間の依存関係を外部から与える仕組みです。
Spring BootではDIの機能が備わっており、DIを使った実装を推奨しています。

詳細のDIの説明は以下に示す参考をご覧ください。

DIによるメリットを以下にいくつか示します。

- テスト容易性が向上します。DIをすることで依存先の結果をモック化することが実装上容易となるためテストが簡単に書けます。
- 変更に強いコードになります。
- 堅牢性が向上します。

### 参考

- https://zenn.dev/tokium_dev/articles/dependency-injection-watanabe
- https://qiita.com/takenakat/items/ec1128371b38e49e88fb
- https://qiita.com/gengen0719/items/65cab20943bf4cce61ca

他にも、Spring Bootを包括的に学ぶための書籍等を紹介しておきます。

- https://amzn.asia/d/7nLBcRc ←おすすめ
- https://amzn.asia/d/9rHVmgW